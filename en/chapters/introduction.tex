\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Introduction}
\chapter*{Introduction}

\chquote{Augeias was king of Elis,\\
in some accounts a son of Helios,\\
in others of Poseidon,\\
and in still others of Phorbas.}{The Library 2.88}{Apollodorus}

In the world of Unix systems, there is no standard way to store configuration. Countless formats can be found, from simple shell variables files to complex, specific, multi-level formats, making the infamous /etc directory a sort of digital Augean stable.

\begin{table}
\begin{center}
  \begin{tabular}{l|l}
    \rowcolor{gray!50}
    Configuration file & Format \\
    \verb!/etc/default/*! & shell variables \\
    \verb!/etc/fstab! & fstab format \\
    \verb!/etc/mtab! & fstab format \\
    \verb!/etc/hosts! & hosts format \\
    \verb!/etc/passwd! & passwd format \\
    \verb!/etc/shadow! & passwd format \\
    \verb!php.ini! & INI file \\
    \verb!my.cnf! & INI file\\
    \verb!gdm.conf! & INI file \\
    \verb!puppet.conf! & INI file \\
  \end{tabular}
  \legend{Some common configuration files and their format}
\end{center}
\end{table}


Augeas provides a way to cleanly manage these configuration files through a unified API.

\section{Configuration Data Editing Approaches}

While system administrators are well aware of the heterogenous state of the configuration data on Unix systems, these configurations have to be edited automatically in many situations.

There are three main approaches to the issue of automating configuration data editing on Unix systems.

\subsection{Keyhole Approaches}

While most programming languages provide modules to edit at least the most common formats, a lot of system administrators and developers have had to manipulate these files using string editing tools such as sed, awk or cut, or even to write scripts dedicated to a specific parsing job. In the majority of these cases, the results are not guaranteed, and you are likely to ruin the configuration files if your parsing expressions are wrong or the file layout changes.

Configuration management tools such as Cfengine provide tools (like AppendIfNoSuchLine) to achieve keyhole approaches, but the problems are similar to using string editing tools: you have no guarantee that the result will be a valid configuration file, and you have to write the regexps yourself.

\todo{Provide examples of using sed or awk}

Augeas is particularly useful to ease and secure this kind of approach.

\subsection{Greenfield approaches}

When you are the main system administrator of a machine and you wish to control all the parameters of the machine, you may want to provide the configuration files entirely. In this case, it is common to set a repository of configuration files, or a database, which will contain the whole configuration as will be deployed to the machines.

\todo{Maybe provide an example such organization or schema}

\subsection{Templating}

If you wish to control whole configuration files but you need a fine-grained mechanism to generate these files, templating is probably the best approach. There are lots of options to achieve this. Puppet, for example, provides ERB templates that let you easily generate configuration files from exported variables.

\todo{Given an example of an ERB template for Puppet for example}

\section{A Unified Configuration API}

In many cases, system administrators and users want to change a single value in their configuration without affecting the rest of it. This is often achieved using the keyhole approach, which as we have seen is not very reliable. A better approach would be to have a unified configuration API that lets you modify configurations in a simple and reliable way, ensuring that the modified files are valid configuration files. This is the goal of Augeas.

\section{What Augeas is not}

A principle on Unix systems ensures the stability and simplicity of the system tools: each tool attempts to do one thing, and to do it well. Augeas is no exception to this rule, so that Augeas is as much defined by the things it does not try to accomplish as by its goals.

Before we dive into what Augeas can do for you, it is important to note the following points.

\subsection{Not an abstraction layer}

Augeas does not attempt to provide an abstraction layer from the native configuration format. The organization of the Augeas tree mirrors closely that of the configuration files it represents.

As an example, if the \nolinkurl{/etc/foo.conf} configuration file contains an include statement such as the following:

\begin{bash}[]
#include /etc/foo.d/*
\end{bash}

Augeas will not attempt to parse the contents of the files in \nolinkurl{/etc/foo.d/*} and add them to the \nolinkurl{/etc/foo.conf} tree. Instead, it will provide a tree like the following:

\begin{augtoolsh}[]
/files/etc/foo.conf
/files/etc/foo.conf/#include = /etc/foo.d/*
\end{augtoolsh}

\verb!#include! is just a parameter of the \nolinkurl{/etc/foo.conf} configuration file and \nolinkurl{/etc/foo.d/*} is the value of the parameter. The contents of \nolinkurl{/etc/foo.d/*} will probably appear in the tree if the lens is able to parse them, but in no way will Augeas make a logical link between \nolinkurl{/etc/foo.conf} and \nolinkurl{/etc/foo.d/*}.

Other software provide this kind of abstraction layer. This is the case of Config::Model, which can use Augeas as a backend, and is able to understand the logic of a configuration files, such as include statements, or the link between several statements in a configuration file.

Another consequence of this non-goal is that the statements in the Augeas tree will appear in the same order as they do in the configuration file. In some cases, it is technically possible to write Augeas lenses that invert parameters or otherwise modify the logic of the configuration statements. Doing this is not recommended, as the Augeas tree should stay as close as possible in its logic to the configuration files it is representing to provide maximum flexibility.

\subsection{Not a cross-platform abstraction layer}

For a similar reason, Augeas does not attempt to be a cross-platform abstraction layer. When Augeas finds Apache configuration files in \nolinkurl{/etc/httpd/httpd.conf} on some operating systems and in \nolinkurl{/etc/apache2/apache2.conf} in others, these files will be represented in the tree as \nolinkurl{/files/etc/httpd/httpd.conf} and \nolinkurl{/files/etc/apache2/apache2.conf} respectively.

Similarly, some operating systems provide their network configuration in \nolinkurl{/etc/sysconfig/network} while others use \nolinkurl{/etc/network/interfaces}. Augeas will represent these two files in different parts of the tree, and the tree will mirror the way each of these files is organized, without attempting to provide a unified way to configure network interfaces across these operating systems.

Other projects such as netcf\footnote{\url{https://fedorahosted.org/netcf}}, based on Augeas, provide a cross-platform abstraction layer to manage network interfaces regardless of the operating system, but it is not Augeas' goal.

\subsection{No remote management support}

When you are dealing with a whole fleet of servers and wish to set a parameter for each of them, it is useful to use a tool that has a network protocol for remote management. Augeas does not attempt to be that tool, and the Augeas API is designed to be a local API.

Remote access to the Augeas API are meant to be added on top of it, not in it.

Puppet\footnote{\url{http://www.puppetlabs.com}} is an example of configuration management tool which supports Augeas as a native type and provides remote management functionality.

\subsection{Very little modelling}

The goal of Augeas is not to understand or otherwise interpret configuration files. As stated before, Augeas does not attempt to provide an abstraction layer, but it provides a light modelling, although very close to the organization of the configuration files.

For example, an \nolinkurl{/etc/hosts} line like the following:

\begin{bash}[]
192.168.0.10    aslan   # Added by NetworkManager
\end{bash}

will be represented by the following tree:

\begin{augtoolsh}[]
/files/etc/hosts
/files/etc/hosts/1
/files/etc/hosts/1/ipaddr = "192.168.0.10"
/files/etc/hosts/1/canonical = "aslan"
/files/etc/hosts/1/#comment = "Added by NetworkManager"
\end{augtoolsh}

The order of the statements is strictly kept; Augeas does not interpret the configuration files per se, but it labels each of the fields on the line to ease access to individual configuration items.

\section{Installing Augeas}

\label{sec:installing_augeas} \index{Installation}

\subsection{Installing from source}

\index{Installation!from source}
\label{sec:installing_from_source}

You might want to install Augeas from source if your distribution does not provide any binary packages, if you simply want to use the latest version of Augeas, or tune compilation parameters.

You can find the latest source code on the Augeas website:

	\url{http://augeas.net/download/}

Next, install the necessary dependencies to build Augeas. The minimal dependencies you will need are the readline headers. You can use one of these commands to install them:

\begin{console}[]
$ sudo yum install readline-devel
$ sudo apt-get install libreadline-dev
\end{console}

Then, extract, compile and install:

\begin{console}[]
$ tar xvzf augeas-0.8.0.tar.gz
$ cd augeas-0.8.0
$ ./configure
$ make && sudo make install
\end{console}



\subsection{Installing from binary packages}

\index{Installation!from packages}

\label{sec:installing_from_packages}

Most distributions provide Augeas packages, often split up into the shared library, the lenses provided with Augeas and the command-line tools.

On Red Hat or Fedora derivatives, you can install the \verb!augeas! package using yum:

\consolecode/$ sudo yum install augeas/

Or on Debian and Ubuntu systems, you can install the Augeas library and the augtool command-line interface with the following:

\consolecode/$ sudo apt-get install augeas-tool/

You might also want to install the documentation package with:

\consolecode/$ sudo apt-get install augeas-doc/

\subsection{Installing from the development head}

\index{Installation!from development head}

Augeas' code is maintained in a public repository which can be cloned and used to test the latest features and fixes before they are released.

If you wish to build and install from the development head, you will need \verb!git! \footnote{provided by the \verb!git-core! package on Debian-based distributions}, \verb!autoconf!, \verb!automake! and \verb!libtool!, as well as the normal dependencies to build Augeas from source. Then follow these instructions:

\begin{console}[]
$ git clone git://git.fedorahosted.org/augeas.git
$ ./autogen.sh
$ ./configure
$ make && sudo make install
\end{console}


\subsection{Building documentation}

Augeas provides documentation in the form of \LaTeX~files and inline documentation in the C API source and lenses, formatted in the NaturalDocs\footnote{\url{http://naturaldocs.org}} format.

If you want to build this documentation, begin with the instructions in section \Nameref{sec:installing_from_source} to retrieve the source code.

On Ubuntu, you can find this documentation already built in the `augeas-doc` package\footnoteref{sec:installing_from_packages}.


\subsubsection{Building the PDF documentation}

In order to build the PDF documentation, you will need to install \verb!pdflatex! on your system, with one of the following commands:

\consolecode|$ sudo yum install texlive-latex|
\consolecode|$ sudo apt-get install texlive-latex-base|

Then add the \texttt{--with\allowbreak-pdfdocs} flag to the \texttt{./configure} call and call \texttt{make}:

\consolecode|$ ./configure --with-pdfdocs|
\consolecode|$ make|

This will generate PDF files in the \verb!doc! directory, which contain mostly theorical information on lenses and their implementation in Augeas\seeref{chap:bx}.


\subsubsection{Building the NaturalDocs documentation}

The NaturalDocs documentation covers the inline documentation for the C API and the lenses shipped with Augeas.

\info{The NaturalDocs documentation is available online at \url{http://augeas.net/docs/references/lenses}}

In order to build this documentation, you need to install \verb!naturaldocs! on your system, using one of these commands:

\consolecode|$ sudo yum install NaturalDocs|
\consolecode|$ sudo apt-get install naturaldocs|

You can then build the documentation by calling \texttt{./configure} with the \texttt{--with\allowbreak-naturaldocs=HTML} or \texttt{--with\allowbreak-naturaldocs=FramedHTML} flags. The first flag will include the HTML header in each generated file, while the second flag will generate HTML frames to read the documentation:

\consolecode|$ ./configure --with-naturaldocs=HTML|
\consolecode|$ make|

This will produce HTML files in the \verb!doc/naturaldocs/output! directory. The \verb!c_api! directory will contain the generated documentation for the C API. The \verb!lenses! directory will be the documentation for the lenses provided with Augeas. You can open the \verb!index.html! file of one of these directories to access the full documentation.


\subsection{Conventions}

This book uses the following conventions:
\begin{itemize}
  \item
    Filesystem paths, Augeas calls and Unix commands are written in a monospace font;
  \item
    When lines are too long in an output, an antislash (\verb!\!) is added and the rest of the line is reported to the next line with an indentation.
\end{itemize}


\todo{Refine conventions}

